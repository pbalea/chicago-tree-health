"""
04_neighborhood_health_map.py
==============================
Creates a 5-panel static map showing health indicators for all
census tracts within 2 miles of IIT's Mies Campus.

No geopandas required — parses WKT geometry manually.

Input (place in data/raw/):
  - CensusTractsTIGER2010_20260129.csv

Input (generated by 01_merge_chicago_data.py):
  - data/processed/merged_chicago_data.csv

Output:
  - outputs/iit_neighborhood_health_map.png
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.colors as mcolors
import matplotlib.cm as cm
from matplotlib.patches import Polygon as MplPolygon
import re
import math
import numpy as np
from pathlib import Path

# ── Paths ──────────────────────────────────────────────────────
RAW       = Path("data/raw")
PROCESSED = Path("data/processed")
OUTPUTS   = Path("outputs")
OUTPUTS.mkdir(parents=True, exist_ok=True)

# ── IIT Mies Campus center ─────────────────────────────────────
IIT_LAT =  41.8354
IIT_LON = -87.6274
RADIUS_MILES = 2.0

# ── Load data ──────────────────────────────────────────────────
print("Loading data...")
tiger  = pd.read_csv(RAW / "CensusTractsTIGER2010_20260129.csv")
merged = pd.read_csv(PROCESSED / "merged_chicago_data.csv")

tiger["GEOID"]  = tiger["GEOID10"].astype(int)
merged["GEOID"] = merged["GEOID"].astype(int)
df = tiger.merge(merged, on="GEOID", how="inner")
print(f"  Merged: {len(df)} tracts")


# ── WKT polygon parser ─────────────────────────────────────────
def parse_wkt_polygons(wkt):
    """Parse WKT MULTIPOLYGON or POLYGON into list of (lons, lats) arrays."""
    polys = []
    coord_blocks = re.findall(r'\(([^()]+)\)', wkt)
    for block in coord_blocks:
        pairs = block.strip().split(',')
        coords = []
        for p in pairs:
            parts = p.strip().split()
            if len(parts) >= 2:
                try:
                    coords.append((float(parts[0]), float(parts[1])))
                except ValueError:
                    pass
        if len(coords) >= 3:
            lons = [c[0] for c in coords]
            lats = [c[1] for c in coords]
            polys.append((lons, lats))
    return polys


# ── Haversine distance ─────────────────────────────────────────
def haversine_miles(lat1, lon1, lat2, lon2):
    R = 3958.8
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (math.sin(dlat/2)**2 +
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
         math.sin(dlon/2)**2)
    return R * 2 * math.asin(math.sqrt(a))


# ── Compute tract centroid from WKT ───────────────────────────
def centroid_from_wkt(wkt):
    polys = parse_wkt_polygons(wkt)
    if not polys:
        return None, None
    all_lons, all_lats = [], []
    for lons, lats in polys:
        all_lons.extend(lons)
        all_lats.extend(lats)
    return sum(all_lats)/len(all_lats), sum(all_lons)/len(all_lons)


# ── Filter tracts within 2 miles of IIT ───────────────────────
print("Filtering tracts within 2 miles of IIT...")
df["centroid_lat"], df["centroid_lon"] = zip(*[
    centroid_from_wkt(row) for row in df["the_geom"]
])
df["dist_miles"] = df.apply(
    lambda r: haversine_miles(IIT_LAT, IIT_LON,
                               r["centroid_lat"], r["centroid_lon"])
    if pd.notna(r["centroid_lat"]) else 999, axis=1
)
nearby = df[df["dist_miles"] <= RADIUS_MILES].copy()
print(f"  Found {len(nearby)} tracts within 2 miles")


# ── Map panels config ──────────────────────────────────────────
PANELS = [
    ("asthma_pct",              "Asthma (%)",
     "YlOrRd",  "Higher = worse"),
    ("AQH_score_popweighted",   "Air Quality + Health\nIndex Score",
     "RdPu",    "Higher = worse"),
    ("PERCENT_CA",              "Tree Canopy (%)",
     "Greens",  "Higher = better"),
    ("physical_inactivity_pct", "Physical\nInactivity (%)",
     "YlOrBr",  "Higher = worse"),
    ("depression_pct",          "Depression (%)",
     "PuRd",    "Higher = worse"),
]

# ── Bounding box ───────────────────────────────────────────────
pad = 0.01
all_lons_flat, all_lats_flat = [], []
for _, row in nearby.iterrows():
    for lons, lats in parse_wkt_polygons(row["the_geom"]):
        all_lons_flat.extend(lons)
        all_lats_flat.extend(lats)

lon_min = min(all_lons_flat) - pad
lon_max = max(all_lons_flat) + pad
lat_min = min(all_lats_flat) - pad
lat_max = max(all_lats_flat) + pad


# ── Draw map ───────────────────────────────────────────────────
print("Rendering map panels...")

fig, axes = plt.subplots(1, 5, figsize=(26, 7.5))
fig.patch.set_facecolor("#1a1a2e")

for ax, (col, title, cmap_name, direction) in zip(axes, PANELS):
    ax.set_facecolor("#1a1a2e")

    vals = nearby[col].dropna()
    vmin, vmax = vals.min(), vals.max()
    cmap = cm.get_cmap(cmap_name)
    norm = mcolors.Normalize(vmin=vmin, vmax=vmax)

    for _, row in nearby.iterrows():
        val   = row[col]
        color = cmap(norm(val)) if pd.notna(val) else "#444444"
        for lons, lats in parse_wkt_polygons(row["the_geom"]):
            ax.add_patch(MplPolygon(list(zip(lons, lats)), closed=True,
                                    facecolor=color, edgecolor="white",
                                    linewidth=0.4, alpha=0.92))

    # IIT marker
    ax.plot(IIT_LON, IIT_LAT, marker="*", color="white",
            markersize=14, zorder=10, markeredgecolor="#FFD700",
            markeredgewidth=1.2)

    # 1-mile and 2-mile reference circles
    for r_miles, ls, alpha in [(1.0, "--", 0.3), (2.0, "-", 0.2)]:
        r_lat = r_miles / 69.0
        r_lon = r_miles / 53.0
        theta = np.linspace(0, 2*np.pi, 100)
        ax.plot(IIT_LON + r_lon*np.cos(theta), IIT_LAT + r_lat*np.sin(theta),
                color="white", linewidth=0.7, linestyle=ls, alpha=alpha, zorder=5)

    ax.set_xlim(lon_min, lon_max)
    ax.set_ylim(lat_min, lat_max)
    ax.set_aspect("equal")
    ax.axis("off")
    ax.set_title(title, color="white", fontsize=11, fontweight="bold",
                 pad=8, linespacing=1.4)

    # Colorbar
    sm = cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])
    cbar = fig.colorbar(sm, ax=ax, orientation="horizontal",
                        fraction=0.046, pad=0.02, shrink=0.85)
    cbar.ax.tick_params(colors="#cccccc", labelsize=7.5)
    cbar.outline.set_edgecolor("#555555")

    # Direction label + missing data note
    n_missing = nearby[col].isna().sum()
    missing_note = f" ({n_missing} tracts no data)" if n_missing > 0 else ""
    ax.text(0.5, -0.07, direction + missing_note, transform=ax.transAxes,
            ha="center", va="top", fontsize=7.5, color="#aaaaaa", style="italic")


# ── Title and legend ───────────────────────────────────────────
fig.suptitle("Health & Environmental Indicators Within 2 Miles of IIT Mies Campus",
             color="white", fontsize=14, fontweight="bold", y=1.0)

legend_elements = [
    plt.Line2D([0], [0], marker="*", color="w", markerfacecolor="white",
               markeredgecolor="#FFD700", markersize=11,
               label="IIT Mies Campus", linestyle="None"),
    plt.Line2D([0], [0], color="white", linewidth=0.9, linestyle="--",
               alpha=0.6, label="1-mile radius"),
    plt.Line2D([0], [0], color="white", linewidth=0.9, linestyle="-",
               alpha=0.5, label="2-mile radius"),
]
fig.legend(handles=legend_elements, loc="lower center", ncol=3,
           fontsize=9, framealpha=0.15, labelcolor="white",
           facecolor="#2a2a4a", edgecolor="#555555",
           bbox_to_anchor=(0.5, -0.04))

plt.tight_layout(rect=[0, 0.04, 1, 0.97])

out_path = OUTPUTS / "iit_neighborhood_health_map.png"
plt.savefig(out_path, dpi=200, bbox_inches="tight",
            facecolor=fig.get_facecolor())
plt.close()
print(f"\nSaved → {out_path}")
print("Done! ✓")
