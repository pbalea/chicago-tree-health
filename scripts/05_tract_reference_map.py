"""
05_tract_reference_map.py
==========================
Companion reference map to the 5-panel health map.
Shows all 52 census tracts within 2 miles of IIT, colored by
community area with tract numbers labeled. Small tracts get
a leader line pointing to a number in the margin.

Input (place in data/raw/):
  - CensusTractsTIGER2010_20260129.csv

Input (generated by 01_merge_chicago_data.py):
  - data/processed/merged_chicago_data.csv

Output:
  - outputs/iit_tract_reference_map.png
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.patches import Polygon as MplPolygon
import matplotlib.patheffects as pe
import re, math
import numpy as np
from pathlib import Path

# ── Paths ──────────────────────────────────────────────────────
RAW       = Path("data/raw")
PROCESSED = Path("data/processed")
OUTPUTS   = Path("outputs")
OUTPUTS.mkdir(parents=True, exist_ok=True)

IIT_LAT =  41.8354
IIT_LON = -87.6274

COMMUNITY_COLORS = {
    "Armour Square":    "#4FC3F7",
    "Bridgeport":       "#FF8A65",
    "Douglas":          "#81C784",
    "Fuller Park":      "#CE93D8",
    "Grand Boulevard":  "#FFD54F",
    "Kenwood":          "#80DEEA",
    "Lower West Side":  "#F48FB1",
    "Mckinley Park":    "#BCAAA4",
    "Near South Side":  "#A5D6A7",
    "New City":         "#FFCC80",
    "Oakland":          "#B39DDB",
}

def parse_wkt_polygons(wkt):
    polys = []
    for block in re.findall(r'\(([^()]+)\)', wkt):
        coords = []
        for p in block.strip().split(','):
            parts = p.strip().split()
            if len(parts) >= 2:
                try: coords.append((float(parts[0]), float(parts[1])))
                except ValueError: pass
        if len(coords) >= 3:
            polys.append(([c[0] for c in coords], [c[1] for c in coords]))
    return polys

def centroid_from_wkt(wkt):
    all_lons, all_lats = [], []
    for lons, lats in parse_wkt_polygons(wkt):
        all_lons.extend(lons); all_lats.extend(lats)
    if all_lats:
        return sum(all_lats)/len(all_lats), sum(all_lons)/len(all_lons)
    return None, None

def poly_area(lons, lats):
    n = len(lons)
    area = sum(lons[i]*lats[(i+1)%n] - lons[(i+1)%n]*lats[i] for i in range(n))
    return abs(area) / 2

def max_poly_area(wkt):
    polys = parse_wkt_polygons(wkt)
    return max((poly_area(l, la) for l, la in polys), default=0)

def haversine_miles(lat1, lon1, lat2, lon2):
    R = 3958.8
    dlat, dlon = math.radians(lat2-lat1), math.radians(lon2-lon1)
    a = (math.sin(dlat/2)**2 +
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
         math.sin(dlon/2)**2)
    return R * 2 * math.asin(math.sqrt(a))

# ── Load ───────────────────────────────────────────────────────
print("Loading data...")
tiger  = pd.read_csv(RAW / "CensusTractsTIGER2010_20260129.csv")
merged = pd.read_csv(PROCESSED / "merged_chicago_data.csv")
tiger["GEOID"]  = tiger["GEOID10"].astype(int)
merged["GEOID"] = merged["GEOID"].astype(int)
df = tiger.merge(merged, on="GEOID", how="inner")
df["centroid_lat"], df["centroid_lon"] = zip(*[centroid_from_wkt(r) for r in df["the_geom"]])
df["dist_miles"] = df.apply(
    lambda r: haversine_miles(IIT_LAT, IIT_LON, r["centroid_lat"], r["centroid_lon"])
    if pd.notna(r["centroid_lat"]) else 999, axis=1)
nearby = df[df["dist_miles"] <= 2.0].copy()
nearby["poly_area"] = [max_poly_area(r) for r in nearby["the_geom"]]
SMALL = nearby["poly_area"].quantile(0.25)
nearby = nearby.sort_values(["COMMUNITY", "NAME10"]).reset_index(drop=True)
nearby["label_num"] = range(1, len(nearby) + 1)

# ── Bounding box ───────────────────────────────────────────────
pad = 0.018
all_lons_f, all_lats_f = [], []
for _, row in nearby.iterrows():
    for lons, lats in parse_wkt_polygons(row["the_geom"]):
        all_lons_f.extend(lons); all_lats_f.extend(lats)
lon_min, lon_max = min(all_lons_f)-pad, max(all_lons_f)+pad
lat_min, lat_max = min(all_lats_f)-pad, max(all_lats_f)+pad

# ── Figure ─────────────────────────────────────────────────────
print("Rendering...")
fig, ax = plt.subplots(figsize=(13, 11))
fig.patch.set_facecolor("#1a1a2e")
ax.set_facecolor("#1a1a2e")

small_tracts = []

for _, row in nearby.iterrows():
    color    = COMMUNITY_COLORS.get(row["COMMUNITY"], "#AAAAAA")
    num      = row["label_num"]
    c_lon    = row["centroid_lon"]
    c_lat    = row["centroid_lat"]
    is_small = row["poly_area"] < SMALL

    for lons, lats in parse_wkt_polygons(row["the_geom"]):
        ax.add_patch(MplPolygon(list(zip(lons, lats)), closed=True,
                                facecolor=color, edgecolor="white",
                                linewidth=0.6, alpha=0.82))

    if not is_small:
        ax.text(c_lon, c_lat, str(num), ha="center", va="center",
                fontsize=7.5, fontweight="bold", color="white", zorder=8,
                path_effects=[pe.withStroke(linewidth=2, foreground="black")])
    else:
        small_tracts.append((num, c_lon, c_lat, color))

# Leader lines for small tracts
if small_tracts:
    margin_x  = lon_max - 0.004
    n         = len(small_tracts)
    lat_start = lat_max - 0.025
    spacing   = (lat_max - lat_min - 0.05) / max(n - 1, 1)

    for i, (num, c_lon, c_lat, color) in enumerate(small_tracts):
        label_y = lat_start - i * spacing
        ax.annotate("", xy=(c_lon, c_lat), xytext=(margin_x - 0.003, label_y),
                    arrowprops=dict(arrowstyle="-", color=color, lw=0.8, alpha=0.7), zorder=6)
        ax.plot(c_lon, c_lat, "o", color=color, markersize=4, zorder=7,
                markeredgecolor="white", markeredgewidth=0.4)
        ax.text(margin_x, label_y, str(num), ha="left", va="center",
                fontsize=7, fontweight="bold", color="white", zorder=9,
                path_effects=[pe.withStroke(linewidth=1.5, foreground="black")])

# IIT star
ax.plot(IIT_LON, IIT_LAT, "*", color="white", markersize=16, zorder=10,
        markeredgecolor="#FFD700", markeredgewidth=1.4)
ax.text(IIT_LON + 0.003, IIT_LAT + 0.004, "IIT Mies Campus",
        fontsize=7.5, color="#FFD700", fontweight="bold", zorder=11,
        path_effects=[pe.withStroke(linewidth=2, foreground="black")])

# Reference circles
theta = np.linspace(0, 2*np.pi, 200)
for r_mi, ls, lbl in [(1.0, "--", "1 mi"), (2.0, "-", "2 mi")]:
    ax.plot(IIT_LON + (r_mi/53)*np.cos(theta), IIT_LAT + (r_mi/69)*np.sin(theta),
            color="white", lw=0.8, ls=ls, alpha=0.25, zorder=5)
    ax.text(IIT_LON + r_mi/53 + 0.001, IIT_LAT, lbl,
            fontsize=6.5, color="white", alpha=0.45, va="center")

# Community area legend
leg = ax.legend(
    handles=[mpatches.Patch(facecolor=c, edgecolor="white", lw=0.5, label=n)
             for n, c in COMMUNITY_COLORS.items()],
    loc="lower left", fontsize=7.5, framealpha=0.25,
    facecolor="#2a2a4a", edgecolor="#555555", labelcolor="white",
    title="Community Area", title_fontsize=8)
leg.get_title().set_color("white")

# Numbered index below map (two columns)
index_lines = [f"  {row['label_num']:>2}. Tract {row['NAME10']} — {row['COMMUNITY']}"
               for _, row in nearby.iterrows()]
mid = math.ceil(len(index_lines) / 2)
fig.text(0.02, -0.01, "\n".join(index_lines[:mid]),
         fontsize=6.2, color="#cccccc", va="top", family="monospace")
fig.text(0.52, -0.01, "\n".join(index_lines[mid:]),
         fontsize=6.2, color="#cccccc", va="top", family="monospace")

ax.set_xlim(lon_min, lon_max)
ax.set_ylim(lat_min, lat_max)
ax.set_aspect("equal")
ax.axis("off")
ax.set_title("Census Tract Reference Map — Within 2 Miles of IIT Mies Campus\n"
             "Numbers correspond to index below",
             color="white", fontsize=12, fontweight="bold", pad=12)

plt.tight_layout()
out_path = OUTPUTS / "iit_tract_reference_map.png"
plt.savefig(out_path, dpi=200, bbox_inches="tight",
            facecolor=fig.get_facecolor())
plt.close()
print(f"Saved → {out_path}")
print("Done! ✓")
